/**
  * Generated by apidoc - http://www.apidoc.me
  * Service version: 0.0.1-dev
  * apidoc:0.11.51 http://www.apidoc.me/gilt/akk-cluster-api-test/0.0.1-dev/play_2_5_client
  */
package com.gilt.akk.cluster.api.test.v0.models {

case class Address(
  guid: _root_.java.util.UUID,
  name: String
)

case class Healthcheck(
  name: String
)

case class Item(
  guid: _root_.java.util.UUID,
  name: String
)

case class Order(
  guid: _root_.java.util.UUID,
  name: String
)

case class PaymentMethod(
  guid: _root_.java.util.UUID,
  name: String
)

case class Session(
  guid: _root_.java.util.UUID,
  user: String,
  shippingAddress: String,
  paymentMethods: String,
  items: Seq[com.gilt.akk.cluster.api.test.v0.models.Item],
  order: String
)

}

package com.gilt.akk.cluster.api.test.v0.models {

package object json {
  import play.api.libs.json.__
  import play.api.libs.json.JsString
  import play.api.libs.json.Writes
  import play.api.libs.functional.syntax._
  import com.gilt.akk.cluster.api.test.v0.models.json._

  private[v0] implicit val jsonReadsUUID = __.read[String].map(java.util.UUID.fromString)

  private[v0] implicit val jsonWritesUUID = new Writes[java.util.UUID] {
    def writes(x: java.util.UUID) = JsString(x.toString)
  }

  private[v0] implicit val jsonReadsJodaDateTime = __.read[String].map { str =>
    import org.joda.time.format.ISODateTimeFormat.dateTimeParser
    dateTimeParser.parseDateTime(str)
  }

  private[v0] implicit val jsonWritesJodaDateTime = new Writes[org.joda.time.DateTime] {
    def writes(x: org.joda.time.DateTime) = {
      import org.joda.time.format.ISODateTimeFormat.dateTime
      val str = dateTime.print(x)
      JsString(str)
    }
  }

  implicit def jsonReadsAkkClusterApiTestAddress: play.api.libs.json.Reads[Address] = {
    (
      (__ \ "guid").read[_root_.java.util.UUID] and
        (__ \ "name").read[String]
      )(Address.apply _)
  }

  def jsObjectAddress(obj: com.gilt.akk.cluster.api.test.v0.models.Address) = {
    play.api.libs.json.Json.obj(
      "guid" -> play.api.libs.json.JsString(obj.guid.toString),
      "name" -> play.api.libs.json.JsString(obj.name)
    )
  }

  implicit def jsonWritesAkkClusterApiTestAddress: play.api.libs.json.Writes[Address] = {
    new play.api.libs.json.Writes[com.gilt.akk.cluster.api.test.v0.models.Address] {
      def writes(obj: com.gilt.akk.cluster.api.test.v0.models.Address) = {
        jsObjectAddress(obj)
      }
    }
  }

  implicit def jsonReadsAkkClusterApiTestHealthcheck: play.api.libs.json.Reads[Healthcheck] = {
    (__ \ "name").read[String].map { x => new Healthcheck(name = x) }
  }

  def jsObjectHealthcheck(obj: com.gilt.akk.cluster.api.test.v0.models.Healthcheck) = {
    play.api.libs.json.Json.obj(
      "name" -> play.api.libs.json.JsString(obj.name)
    )
  }

  implicit def jsonWritesAkkClusterApiTestHealthcheck: play.api.libs.json.Writes[Healthcheck] = {
    new play.api.libs.json.Writes[com.gilt.akk.cluster.api.test.v0.models.Healthcheck] {
      def writes(obj: com.gilt.akk.cluster.api.test.v0.models.Healthcheck) = {
        jsObjectHealthcheck(obj)
      }
    }
  }

  implicit def jsonReadsAkkClusterApiTestItem: play.api.libs.json.Reads[Item] = {
    (
      (__ \ "guid").read[_root_.java.util.UUID] and
        (__ \ "name").read[String]
      )(Item.apply _)
  }

  def jsObjectItem(obj: com.gilt.akk.cluster.api.test.v0.models.Item) = {
    play.api.libs.json.Json.obj(
      "guid" -> play.api.libs.json.JsString(obj.guid.toString),
      "name" -> play.api.libs.json.JsString(obj.name)
    )
  }

  implicit def jsonWritesAkkClusterApiTestItem: play.api.libs.json.Writes[Item] = {
    new play.api.libs.json.Writes[com.gilt.akk.cluster.api.test.v0.models.Item] {
      def writes(obj: com.gilt.akk.cluster.api.test.v0.models.Item) = {
        jsObjectItem(obj)
      }
    }
  }

  implicit def jsonReadsAkkClusterApiTestOrder: play.api.libs.json.Reads[Order] = {
    (
      (__ \ "guid").read[_root_.java.util.UUID] and
        (__ \ "name").read[String]
      )(Order.apply _)
  }

  def jsObjectOrder(obj: com.gilt.akk.cluster.api.test.v0.models.Order) = {
    play.api.libs.json.Json.obj(
      "guid" -> play.api.libs.json.JsString(obj.guid.toString),
      "name" -> play.api.libs.json.JsString(obj.name)
    )
  }

  implicit def jsonWritesAkkClusterApiTestOrder: play.api.libs.json.Writes[Order] = {
    new play.api.libs.json.Writes[com.gilt.akk.cluster.api.test.v0.models.Order] {
      def writes(obj: com.gilt.akk.cluster.api.test.v0.models.Order) = {
        jsObjectOrder(obj)
      }
    }
  }

  implicit def jsonReadsAkkClusterApiTestPaymentMethod: play.api.libs.json.Reads[PaymentMethod] = {
    (
      (__ \ "guid").read[_root_.java.util.UUID] and
        (__ \ "name").read[String]
      )(PaymentMethod.apply _)
  }

  def jsObjectPaymentMethod(obj: com.gilt.akk.cluster.api.test.v0.models.PaymentMethod) = {
    play.api.libs.json.Json.obj(
      "guid" -> play.api.libs.json.JsString(obj.guid.toString),
      "name" -> play.api.libs.json.JsString(obj.name)
    )
  }

  implicit def jsonWritesAkkClusterApiTestPaymentMethod: play.api.libs.json.Writes[PaymentMethod] = {
    new play.api.libs.json.Writes[com.gilt.akk.cluster.api.test.v0.models.PaymentMethod] {
      def writes(obj: com.gilt.akk.cluster.api.test.v0.models.PaymentMethod) = {
        jsObjectPaymentMethod(obj)
      }
    }
  }

  implicit def jsonReadsAkkClusterApiTestSession: play.api.libs.json.Reads[Session] = {
    (
      (__ \ "guid").read[_root_.java.util.UUID] and
        (__ \ "user").read[String] and
        (__ \ "shipping_address").read[String] and
        (__ \ "payment_methods").read[String] and
        (__ \ "items").read[Seq[com.gilt.akk.cluster.api.test.v0.models.Item]] and
        (__ \ "order").read[String]
      )(Session.apply _)
  }

  def jsObjectSession(obj: com.gilt.akk.cluster.api.test.v0.models.Session) = {
    play.api.libs.json.Json.obj(
      "guid" -> play.api.libs.json.JsString(obj.guid.toString),
      "user" -> play.api.libs.json.JsString(obj.user),
      "shipping_address" -> play.api.libs.json.JsString(obj.shippingAddress),
      "payment_methods" -> play.api.libs.json.JsString(obj.paymentMethods),
      "items" -> play.api.libs.json.Json.toJson(obj.items),
      "order" -> play.api.libs.json.JsString(obj.order)
    )
  }

  implicit def jsonWritesAkkClusterApiTestSession: play.api.libs.json.Writes[Session] = {
    new play.api.libs.json.Writes[com.gilt.akk.cluster.api.test.v0.models.Session] {
      def writes(obj: com.gilt.akk.cluster.api.test.v0.models.Session) = {
        jsObjectSession(obj)
      }
    }
  }
}
}

package com.gilt.akk.cluster.api.test.v0 {

object Bindables {

  import play.api.mvc.{PathBindable, QueryStringBindable}
  import org.joda.time.{DateTime, LocalDate}
  import org.joda.time.format.ISODateTimeFormat
  import com.gilt.akk.cluster.api.test.v0.models._

  // Type: date-time-iso8601
  implicit val pathBindableTypeDateTimeIso8601 = new PathBindable.Parsing[org.joda.time.DateTime](
    ISODateTimeFormat.dateTimeParser.parseDateTime(_), _.toString, (key: String, e: _root_.java.lang.Exception) => s"Error parsing date time $key. Example: 2014-04-29T11:56:52Z"
  )

  implicit val queryStringBindableTypeDateTimeIso8601 = new QueryStringBindable.Parsing[org.joda.time.DateTime](
    ISODateTimeFormat.dateTimeParser.parseDateTime(_), _.toString, (key: String, e: _root_.java.lang.Exception) => s"Error parsing date time $key. Example: 2014-04-29T11:56:52Z"
  )

  // Type: date-iso8601
  implicit val pathBindableTypeDateIso8601 = new PathBindable.Parsing[org.joda.time.LocalDate](
    ISODateTimeFormat.yearMonthDay.parseLocalDate(_), _.toString, (key: String, e: _root_.java.lang.Exception) => s"Error parsing date $key. Example: 2014-04-29"
  )

  implicit val queryStringBindableTypeDateIso8601 = new QueryStringBindable.Parsing[org.joda.time.LocalDate](
    ISODateTimeFormat.yearMonthDay.parseLocalDate(_), _.toString, (key: String, e: _root_.java.lang.Exception) => s"Error parsing date $key. Example: 2014-04-29"
  )



}

}


package com.gilt.akk.cluster.api.test.v0 {

object Constants {

  val BaseUrl = "http://localhost:9000"
  val Namespace = "com.gilt.akk.cluster.api.test.v0"
  val UserAgent = "apidoc:0.11.51 http://www.apidoc.me/gilt/akk-cluster-api-test/0.0.1-dev/play_2_5_client"
  val Version = "0.0.1-dev"
  val VersionMajor = 0

}

class Client(
  ws: play.api.libs.ws.WSClient,
  val baseUrl: String = "http://localhost:9000",
  auth: scala.Option[com.gilt.akk.cluster.api.test.v0.Authorization] = None,
  defaultHeaders: Seq[(String, String)] = Nil
) extends interfaces.Client {
  import com.gilt.akk.cluster.api.test.v0.models.json._

  private[this] val logger = play.api.Logger("com.gilt.akk.cluster.api.test.v0.Client")

  logger.info(s"Initializing com.gilt.akk.cluster.api.test.v0.Client for url $baseUrl")

  def addresses: Addresses = Addresses

  def healthchecks: Healthchecks = Healthchecks

  def orders: Orders = Orders

  def paymentMethods: PaymentMethods = PaymentMethods

  def sessions: Sessions = Sessions

  object Addresses extends Addresses {
    override def get(
      uuid: String,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[com.gilt.akk.cluster.api.test.v0.models.Address]] = {
      _executeRequest("GET", s"/session/${play.utils.UriEncoding.encodePathSegment(uuid, "UTF-8")}/addresses", requestHeaders = requestHeaders).map {
        case r if r.status == 200 => _root_.com.gilt.akk.cluster.api.test.v0.Client.parseJson("Seq[com.gilt.akk.cluster.api.test.v0.models.Address]", r, _.validate[Seq[com.gilt.akk.cluster.api.test.v0.models.Address]])
        case r => throw new com.gilt.akk.cluster.api.test.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200")
      }
    }
  }

  object Healthchecks extends Healthchecks {
    override def get(
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.akk.cluster.api.test.v0.models.Healthcheck] = {
      _executeRequest("GET", s"/healthcheck", requestHeaders = requestHeaders).map {
        case r if r.status == 200 => _root_.com.gilt.akk.cluster.api.test.v0.Client.parseJson("com.gilt.akk.cluster.api.test.v0.models.Healthcheck", r, _.validate[com.gilt.akk.cluster.api.test.v0.models.Healthcheck])
        case r => throw new com.gilt.akk.cluster.api.test.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200")
      }
    }
  }

  object Orders extends Orders {
    override def get(
      uuid: String,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.akk.cluster.api.test.v0.models.Order] = {
      _executeRequest("GET", s"/sessions/${play.utils.UriEncoding.encodePathSegment(uuid, "UTF-8")}/order", requestHeaders = requestHeaders).map {
        case r if r.status == 200 => _root_.com.gilt.akk.cluster.api.test.v0.Client.parseJson("com.gilt.akk.cluster.api.test.v0.models.Order", r, _.validate[com.gilt.akk.cluster.api.test.v0.models.Order])
        case r => throw new com.gilt.akk.cluster.api.test.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200")
      }
    }
  }

  object PaymentMethods extends PaymentMethods {
    override def get(
      uuid: String,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[com.gilt.akk.cluster.api.test.v0.models.PaymentMethod]] = {
      _executeRequest("GET", s"/session/${play.utils.UriEncoding.encodePathSegment(uuid, "UTF-8")}/payment_methods", requestHeaders = requestHeaders).map {
        case r if r.status == 200 => _root_.com.gilt.akk.cluster.api.test.v0.Client.parseJson("Seq[com.gilt.akk.cluster.api.test.v0.models.PaymentMethod]", r, _.validate[Seq[com.gilt.akk.cluster.api.test.v0.models.PaymentMethod]])
        case r => throw new com.gilt.akk.cluster.api.test.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200")
      }
    }
  }

  object Sessions extends Sessions {
    override def get(
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.akk.cluster.api.test.v0.models.Session] = {
      _executeRequest("GET", s"/session", requestHeaders = requestHeaders).map {
        case r if r.status == 200 => _root_.com.gilt.akk.cluster.api.test.v0.Client.parseJson("com.gilt.akk.cluster.api.test.v0.models.Session", r, _.validate[com.gilt.akk.cluster.api.test.v0.models.Session])
        case r => throw new com.gilt.akk.cluster.api.test.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200")
      }
    }
  }

  def _requestHolder(path: String): play.api.libs.ws.WSRequest = {

    val holder = ws.url(baseUrl + path).withHeaders(
      "User-Agent" -> Constants.UserAgent,
      "X-Apidoc-Version" -> Constants.Version,
      "X-Apidoc-Version-Major" -> Constants.VersionMajor.toString
    ).withHeaders(defaultHeaders : _*)
    auth.fold(holder) {
      case Authorization.Basic(username, password) => {
        holder.withAuth(username, password.getOrElse(""), play.api.libs.ws.WSAuthScheme.BASIC)
      }
      case a => sys.error("Invalid authorization scheme[" + a.getClass + "]")
    }
  }

  def _logRequest(method: String, req: play.api.libs.ws.WSRequest)(implicit ec: scala.concurrent.ExecutionContext): play.api.libs.ws.WSRequest = {
    val queryComponents = for {
      (name, values) <- req.queryString
      value <- values
    } yield s"$name=$value"
    val url = s"${req.url}${queryComponents.mkString("?", "&", "")}"
    auth.fold(logger.info(s"curl -X $method $url")) { _ =>
      logger.info(s"curl -X $method -u '[REDACTED]:' $url")
    }
    req
  }

  def _executeRequest(
    method: String,
    path: String,
    queryParameters: Seq[(String, String)] = Nil,
    requestHeaders: Seq[(String, String)] = Nil,
    body: Option[play.api.libs.json.JsValue] = None
  )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[play.api.libs.ws.WSResponse] = {
    method.toUpperCase match {
      case "GET" => {
        _logRequest("GET", _requestHolder(path).withHeaders(requestHeaders:_*).withQueryString(queryParameters:_*)).get()
      }
      case "POST" => {
        _logRequest("POST", _requestHolder(path).withHeaders(_withJsonContentType(requestHeaders):_*).withQueryString(queryParameters:_*)).post(body.getOrElse(play.api.libs.json.Json.obj()))
      }
      case "PUT" => {
        _logRequest("PUT", _requestHolder(path).withHeaders(_withJsonContentType(requestHeaders):_*).withQueryString(queryParameters:_*)).put(body.getOrElse(play.api.libs.json.Json.obj()))
      }
      case "PATCH" => {
        _logRequest("PATCH", _requestHolder(path).withHeaders(requestHeaders:_*).withQueryString(queryParameters:_*)).patch(body.getOrElse(play.api.libs.json.Json.obj()))
      }
      case "DELETE" => {
        _logRequest("DELETE", _requestHolder(path).withHeaders(requestHeaders:_*).withQueryString(queryParameters:_*)).delete()
      }
      case "HEAD" => {
        _logRequest("HEAD", _requestHolder(path).withHeaders(requestHeaders:_*).withQueryString(queryParameters:_*)).head()
      }
      case "OPTIONS" => {
        _logRequest("OPTIONS", _requestHolder(path).withHeaders(requestHeaders:_*).withQueryString(queryParameters:_*)).options()
      }
      case _ => {
        _logRequest(method, _requestHolder(path).withHeaders(requestHeaders:_*).withQueryString(queryParameters:_*))
        sys.error("Unsupported method[%s]".format(method))
      }
    }
  }

  /**
    * Adds a Content-Type: application/json header unless the specified requestHeaders
    * already contain a Content-Type header
    */
  def _withJsonContentType(headers: Seq[(String, String)]): Seq[(String, String)] = {
    headers.find { _._1.toUpperCase == "CONTENT-TYPE" } match {
      case None => headers ++ Seq(("Content-Type" -> "application/json; charset=UTF-8"))
      case Some(_) => headers
    }
  }

}

object Client {

  def parseJson[T](
    className: String,
    r: play.api.libs.ws.WSResponse,
    f: (play.api.libs.json.JsValue => play.api.libs.json.JsResult[T])
  ): T = {
    f(play.api.libs.json.Json.parse(r.body)) match {
      case play.api.libs.json.JsSuccess(x, _) => x
      case play.api.libs.json.JsError(errors) => {
        throw new com.gilt.akk.cluster.api.test.v0.errors.FailedRequest(r.status, s"Invalid json for class[" + className + "]: " + errors.mkString(" "))
      }
    }
  }

}

sealed trait Authorization
object Authorization {
  case class Basic(username: String, password: Option[String] = None) extends Authorization
}

package interfaces {

trait Client {
  def baseUrl: String
  def addresses: com.gilt.akk.cluster.api.test.v0.Addresses
  def healthchecks: com.gilt.akk.cluster.api.test.v0.Healthchecks
  def orders: com.gilt.akk.cluster.api.test.v0.Orders
  def paymentMethods: com.gilt.akk.cluster.api.test.v0.PaymentMethods
  def sessions: com.gilt.akk.cluster.api.test.v0.Sessions
}

}

trait Addresses {
  def get(
    uuid: String,
    requestHeaders: Seq[(String, String)] = Nil
  )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[com.gilt.akk.cluster.api.test.v0.models.Address]]
}

trait Healthchecks {
  def get(
    requestHeaders: Seq[(String, String)] = Nil
  )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.akk.cluster.api.test.v0.models.Healthcheck]
}

trait Orders {
  def get(
    uuid: String,
    requestHeaders: Seq[(String, String)] = Nil
  )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.akk.cluster.api.test.v0.models.Order]
}

trait PaymentMethods {
  def get(
    uuid: String,
    requestHeaders: Seq[(String, String)] = Nil
  )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[com.gilt.akk.cluster.api.test.v0.models.PaymentMethod]]
}

trait Sessions {
  def get(
    requestHeaders: Seq[(String, String)] = Nil
  )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.akk.cluster.api.test.v0.models.Session]
}

package errors {

case class FailedRequest(responseCode: Int, message: String, requestUri: Option[_root_.java.net.URI] = None) extends _root_.java.lang.Exception(s"HTTP $responseCode: $message")

}

}